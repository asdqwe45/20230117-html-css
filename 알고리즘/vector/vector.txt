[Vector의 중요성]
DFS,BFS 에서 인접리스트 초기화시
vector 자료구조를 사용하기 때문에 
vector를 잘 알아두시는 것이 좋습니다.

[Vector, 그래서 무엇이 좋은가?]
배열은 크기를 우리가 지정하면 바꿀 수가 없습니다.
(예. int arr[1000] ={0,}; 1000칸의 배열을 만듦)
따라서, 추후에 뭔가 값이 더 들어와야 하는 상황이 생긴다면
그렇게 할 수가 없을 것이고
처음부터 칸을 많이 만들어두면 메모리 낭비가 될 수 있습니다.
Vector는 이런 부분에서 자유롭습니다.
왜냐하면 동적 배열 클래스로 구현이 되어있기 때문에
쉽게 얘기해서 값이 들어오는만큼 칸 수를 늘려주는 것이 가능하기 때문에죠.

[Vector, 어떻게 쓰는가?]
먼저

#include <vector> 를 헤더에 추가해주시면 됩니다.

중요도는 추후 진도 및 학습에 영향을 줄 수 있는 정도를 표현합니다.

중요도 ★★★

변수 이름을 'v' 라고 지정하고 작성하겠습니다~

vector<int> v;
비어있는 벡터 v 생성 ! (size,capacity는 0 이겠죠?)
-> 벡터 안에 얼마나 들어갈지 모를때는 보통 이렇게 만들어둡니다.

vector<int> v(n);
기본값 0을 원소로 n개 가지는 벡터 v를 생성!
예시) vector<int> v(5) -> 0을 원소로 가지고 있는 5칸의 벡터 v 생성

vector<int> v(n, NUM);
-> NUM 을 원소로 가지는 n개의 벡터 v를 생성 !

예시) vector<int> v(10, 5) -> 5를 원소로 가지고 있는 10칸의 벡터 v 생성

v.push_back(NUM);
-> 벡터의 마지막 원소 뒤에 NUM을 원소로 가지는 값 추가

예시) 
vector<int> v; // 비어있는 벡터 v 생성 (size,capacity 0)

v.push_back(3);
v.push_back(5);
v.push_back(7);
를 하게되면

v[0] = 3;
v[1] = 5;
v[2] = 7;
이 되겠죠?

사이즈는 3 , capacity는 컴파일러마다 다르기 때문에
늘려보시면서 capacity 값을 확인해보시면 좋습니다.

v.pop_back();
-> 마지막 원소 빼기

v.clear()
-> 원소를 전부 제거, 단 늘어났던 메모리(Capacity)는 남아있고
Size만 줄어듭니다. 이에 대해서 이미 늘어난 메모리를 줄여주려면
Shrink To Fit , Swap 등을 이용하셔야 하는데
코테에서 해당 부분까지 필요한 경우는 많지 않습니다.

v.front();
첫번째 원소 참조
예시) 벡터 안에 원소를 잔뜩 넣어보시고
       cout << v.front(); 를 해보세요!

v.back();
마지막 원소 참조
예시) 벡터 안에 원소를 잔뜩 넣어보시고
        cout << v.back(); 를 해보세요 !

v.begin();
-> 첫번째 위치

v.end();
-> 마지막의 다음 위치

[9번과 10번은 추후에 

#include <algorithm> 을 헤더에 추가해서 사용할
'sort' 에서 사용하는 경우가 많기 때문에
알아두시면 너무 좋습니다]

중요도 ★★

v.erase(해당주소 + 몇 번째 값?);
예를 들어, 시작 주소에서 4번째 인덱스의 원소 삭제 원할시
v.erase(v.begin + 4 );

-> v[4] 삭제됨.

또 다른 예시로는

v.erase(v.begin)

-> 맨 앞 원소 삭제. 

v.insert(해당주소 , NUM);
예를 들어, 제일 처음에 숫자 1을 삽입하고 싶다면
v.insert(v.begin() , 1);

다른 예시로, 제일 끝에 숫자 7을 삽입하고 싶다면
v.insert(v.end(), 7);