디바이스 드라이버
  - /dev/ 디렉터리에서 확인 가능한 것들
  - ls -al 시,
       맨 앞에 c : 캐릭터
                 b : 블럭
                 d : 디렉토리
       major num, minor num 확인 가능

디바이스 파일 = 디바이스 노드
디바이스 파일 != 디바이스 드라이버


app 은 하드웨어 직접 접근 불가능
대신 app은 디바이스 파일을 통해 하드웨어 제어
  시스템콜 ioctl  open close read write

하드웨어 변경시 커널 빌드 또? X
디바이스 드라이버만 다시 제ㅐ작

SW 인터페이스를 통해, 애플리케이션이 하드웨어 스펙을 이해하지 않아도 된다.

펌웨어나 디바이스 드라이버나, 속도 비교, 개발 난이도 무의미
연봉 비교도 무의미

애플리케이션과 커널은 분리되어 있기 때문에, 앱 코드에 디바이스 드라이버에서 쓰는 라이브러리, 코드 등 쓸 수 있나? X
함수는 static, 전역변수 자주 사용 안함
함수명을 모듈명_XXXX로 짓는 경향

ioctl
  하드웨어 제어를 목적으로 사용하는 input output control 이라는 의미의 시스템콜

커널 모듈
  - 커널 내부에 삽입/제거될 수 있는 바이너리 open,close != insmod rmmod
  - 디바이스 드라이버는 커널 빌드 시 모듈 형태로 포함될 수 있으나
    디바이스 드라이버는 전부 다 커널 모듈은 아님
  - 디바이스 드라이버는 커널 모듈 형태로 장치를 제어할 수 있습니다.

chrdev VS blkdev VS netdev
  - 바이트 단위로 값 전달 : chrdev 
  - 블록 단위로 값 전달 : blkdev
  - 네트워크 소켓 : netdev
 일반적인 임베디드 장치 : chrdev

커널빌드
  - 특정 커널 버전에 맞는 디바이스 드라이버를 개발
  - 커널 헤더를 얻기 위함
  - 커널 헤더는 디바이스 드라이버 개발 시 반드시 필요
  - 커널 헤더만 따로 설치 가능 ( 라즈베리파이도 리눅스거든요)
  - 커널 빌드하면 커널 헤더는 부산물
  - 커널 빌드를 한다고해서 보드 작동 테스트를 할 수 있을 까?X

mknod
  노드 파일 만드는 명령어 => 유틸리티

insmod
  커널에 디바이스 모듈을 넣으 때

rmmod
  커널에 디바이스 모듈을 뺄대

file operations 구조체: application에서 디바이스 파일에 시스템콜 사용 시 호출될 콜백함수

open() - .open
close() - .release

insmod - module_init()
rmmod - module_exit()

dmesg -w
  커널로그 실시간 확인

uname -r
  커널 버전 확인

major VS minor

major num
  - 제어하려는 디바이스를 구분하기 위해 커널이 사용하는 번호의 이름
  - 디바이스 파일에서 디바이스를 구분하고자 사용하는 번호
  - 즉 디바이스 종류

minor num 
  - 개발자가 정하기 나름. 하위 카테고리

BIOS
 - 기본적인 I/O를 위한 펌웨어
 - 부팅 시 바로 동작\
 - CMOS(하드웨어)값도 수정이 가능한데

UEFI
  - BIOS를 대체하는 펌웨어
  - GUI
  - GPT: 2.2TB 이상의 디스크 사용 지원 (이거 때문에 UEFI 사용)

POST
  - 컴퓨터에 전원 공급 시, 패리퍼럴 동작 확인을 위해 BIOS가 동작시키는 진단 과정
 
패리퍼럴 
  CPU와 메모리를 제외한

Cross VS native compile

Cross compile 
  - 타켓보드와 개발보드의 코어 종류가 다른 환경에서
    타켓 보드에 맞는 컴파일러로 컴파일
  - 개발의 편의 증가
  - 빌드 속도도 빠름
  - 빌드된 결과물은 상대적으로 느릴 수 밖에

native compile
  - 해당 타겟보드에서 컴파일
  - 개발 불편
  - 빌드 속도 느림
  - 빌드된 결과물은 빠름

부트로더
  0- 운영체제가 시동되기 이전에 미리 실행되면서
  - 커널이 올바르게 동작하기 위해 필요한 모든 관련작업을 마무리하고
  - OS를 시동시키기 위한 목저을 가진 프로그램
  - 부트스트랩 또는 부트스트랩 로더 라고도 불림
  - GRUB , U-boot

BL0
  - 메모리/필수 장치를 초기화하고, BL1 또느 BL2 부트로더 적재 후, 제어권 넘김
  - 침셉회사에서 만듬
  - 커널을 적재하지 않습니다.

GRUB
  - Grand Unified Bootloader
  - 리눅스 배포판에서 많이 사용되는 부트로더

U-boot
  - ARM 계열에서 자주 쓰이는 오픈소스 부트로더
  - BL1 또는 BL2 부트로더, 리눅스 커널 적재 시 사용
  - Universal BootLoader . 임베디드에서 인기있는데
  - 여러 디바이스들이 쓸 수 있는 통합형 부트로더
  - 메모리, 디스크에 적힌 값 확인 가능
  - 커맨드 모드에서 사용자 정의코드를 만들어, 디바이스 드라이버 없이 gpio제어 코드를 만들 수 있음
  - u-boot 메모리 및 파일 시스템을 거치지 않은 장치 테스트 프로그램 제작
  - 파일 시스템 내부 파일 확인 가능(ls)
  - 즉, 부트로더이지만, mmc 장치의 파일시스템도 확인 가능
  - 부트로더이기 때문에, 사용X

리눅스에서 디바이스 드라이버 개발  VS  부트로더에서 펌웨어 개발

리눅스는 메모리 접근이 귀찮음
커널에 모듈 형태로 디바이스 드라이버를 제작하여 넣는 방식으로 개발